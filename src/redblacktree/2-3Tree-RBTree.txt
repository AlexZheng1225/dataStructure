2-3树: 每个节点有2个或3个孩子，是绝对平衡的树
满足二分搜索树的基本性质，但不是一种二叉树
2-3树的节点可以存放一个元素（2节点）或两个元素（3节点）

2-3树是如何维持绝对的平衡？
在2-3树中，添加节点永远不会添加到一个空的位置



红黑树和2-3树的等价性

红黑树中，所有的红色节点都应该向左倾斜[左倾红黑树]     ||| [也可以实现右倾的红黑树]


红黑树的五条性质
1.每个节点或者都是红色的，或者都是黑色的。
2.根节点是黑色的。
3.每一个叶子节点（最后的空节点）是黑色的。
4.如果一个节点是红色的，那么他的孩子节点一定是黑色的。
5.从任意一个节点到叶子节点，经过的黑色节点是一样多的。

通常说，红黑树是保持“黑平衡”的二叉树，严格上讲，黑平衡二叉树不是平衡二叉树。最大高度2logn(比AVL Tree还要高些),时间复杂度为Ologn

使用红黑树进行添加和删除 效率比AVL Tree更高

红黑树的添加
-->左旋转
    //   node                     x
    //  /   \     左旋转         /  \
    // T1   x   --------->   node   T3
    //     / \              /   \
    //    T2 T3            T1   T2

-->右旋转
    //     node                   x
    //    /   \     右旋转       /  \
    //   x    T2   ------->   y   node
    //  / \                       /  \
    // y  T1                     T1  T2

-->颜色翻转
所谓的红色节点，指的是红色节点和父亲节点是融合在一起的
当形成四节点时，3-node中的左右融合节点都为红色 例如 37-42-66 31/42是红色节点
临时的四节点要拆分成三个二节点组成的树，代表这三个节点都是黑色的节点，每个黑色的节点左侧没有红色节点的话，
代表他是一个单独的二节点，这种情况下不需要旋转，改变颜色即可，即讲42的两个孩子节点都变成黑色节点，自身（根节点要继续向上做融合，意味着）变为红色节点


性能测试查询中红黑树并不占优势，红黑树真正优势是在进行添加或删除的操作。

Java中有序（有序：红黑树本身是个二分搜索树）的映射（java.util中的TreeMap）或有序的集合（java.util中的reeSet）的底层均为红黑树

红黑树的性能总结：
对于完全随机的数据，普通的二分搜索树很好用，
缺点：极端情况下会退化为链表（或者高度不平衡）
对于查询较多的使用情况，AVL树很好用！
红黑树牺牲了平衡性（2logn的高度），但总体而言，红黑树的统计性能更优（综合增删改查所有的操作）。

下面要懂：
红黑树（与2-3数的等价关系）
RBTree本质上是一个保持黑平衡的数据结构，从某种程度上来讲牺牲了平衡性，但是统计性能更优，在添加和删除节点操作室拥有比AVL数更好的性能，
综合来看，RBT是比AVL更实用，更加好的可以保持自平衡的数据结构。

红黑树中删除节点是非常复杂的，比添加节点还复杂（面试99%不会让你实现）



PS:提到统计性能更优，还有另外一种统计性能优秀的树结构：Splay Tree(伸展树)
局部性原理：刚被访问的内容下次高概率被再次访问


