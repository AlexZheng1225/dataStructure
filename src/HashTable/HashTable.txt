--哈希表：
“键”通过[哈希函数]转换为”索引“
很难保证每一个”键“通过哈希函数的转换对应不同的“索引”➡Hash冲突➡解决哈希冲突⬅在哈希表上操作

哈希表充分体现了算法设计领域的经典思想：空间换时间
哈希表时时间和空间之间的平衡
哈希函数的设计是很重要的
“键”通过哈希函数得到的“索引”分布越均匀越好



--对于哈希表来说，主要关心：
一是哈希函数的设计
二是发生哈希冲突怎么处理


只关注一般的哈希函数的设计原则



--哈希函数的设计
整型：
小范围正整数直接使用
小范围负整数进行偏移(例如：-100~100 —————> 0~200)
大整数（例如身份证号）
通常做法：取模（比方，取身份证后四位，等同于mod 10000）
当mod 1000000时，会造成分布不均匀 一个简单解决方法:模一个素数




--Hash函数的设计：
转为整型处理----并不是唯一的方法；
设计时要遵循以下原则：
1.一致性：如果a==b，则hash(a)==hash(b)
2.高效性：计算高效简便
3.均匀性：哈希值均匀分布 (模一个合适的素数)



Java中默认的hashcode的实现是根据创建的Object的地址对应的转化为一个整型

对于我们自定义的类不覆盖hashcode方法，java并不会报错，但是逻辑可能不是我们希望的那个逻辑。
另一方面，当使用hashSet或者hashMap的时候，我们自己写的hashCode只是用于帮助我们计算hash函数的值
但当产生hash冲突时，我们依然需要比较两个不同的对象他们之间是否是相等的。
（也就是说，他们对应的hash函数的值虽然相等，此时产生hash冲突，此时为了辨别两个类的不同，就需要真正的看两个类是否是相等的）
重写hashCode方法的同时一般同时覆盖equals方法



--哈希冲突的处理----链地址法[Seperate Chaining]
hashcode(k1)%M 求出来可能为负数
解决：直接对hashcode(k1)的值求绝对值即可
(hashcode(k1) & 0x7fffffff) % M

将求出来的绝对值存进一个数组中，当有重复的时候，可以跟在后面，我们可以在数组中存储以查找表，可以是链表，也可以是平衡树结构
当数据较少时使用链表更好 数据多时使用平衡树结构更好
后：可以看做数组中存储的都是一个TreeMap，本质上来说
HashMap就是一个TreeMap数组
HashSet就是一个TreeSet数组
在java8之前，(数组)每一个位置对应一个链表
java8开始，当哈希冲突达到一定程度时，每一个位置从链表转成红黑树（实际上是转为TreeMap，但是TreeMap的底层就是红黑树）


HashTable性能相比BST/AVL Tree/更优，和RBTree接近(HashTable更优)



--hashtable的动态空间处理
hashtable seperate chaining消耗的时间主要是在每一个地址的链表的相应的消耗上(总共M地址，放入hashtable的元素为N，如果每个地址
是链表，则时间复杂度O(N/M)；如果每个地址是平衡树，则时间复杂度为Olog(N/M)[平均来看],最坏的情况，都hash冲突的话，则会变成O(N)或者Olog(N))
而数组是支持随机查找的(O(1)复杂度),在这里消耗不了太多时间

hashtable的优势是可以让时间复杂度变成O(1)级别的，之所以在这边不能实现是因为M的值被固定了，N可以趋于无穷，那么整体趋于无穷，
M应该为动态的，和动态数组一样需要resize，但hashtable一旦被开辟，从某种意义上讲，相当于每个空间都被占据了，所以不能想动态数组那样
进行填满数组了再扩容这种说法，

优化方法：平均每个地址承载的元素多过一定程度，即扩容 N/M >= upperTol
平均每个地址承载的元素少过一定程度，即缩容 N/M <= lowerTol

加入resize之后，扩容后的hash表性能明显优于平衡树的性能，
时间复杂度分析:
之前动态数组的平均复杂度为O(1)
对于hashtable来说，原理大致相同，元素数从N增加到upperTol*N，地址空间增倍，平均复杂度O(1)
平均每个操作在O（lowerTol） ~ O（upperTol），-----> O(1)
缩容同理


--更复杂的动态空间处理方法
扩容M --> 2*M 那么扩容后的数字已经不是素数了
解决方案--->数学领域中已经有了这种表格，直接使用就可以了
解决方案：







